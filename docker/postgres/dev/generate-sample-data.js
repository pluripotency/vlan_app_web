'use strict';

const fs = require('fs/promises');
const path = require('path');

const DEV_DIR = path.resolve(__dirname);
const TSV_DIR = path.join(DEV_DIR, 'tsv');
const OUTPUT_FILE = path.join(DEV_DIR, 'initdb/02-example-data.sql');

const REQUEST_STATUS = new Set(['pending', 'approved', 'rejected']);

async function main() {
  const users = await readTsv('users.tsv', ['subject', 'name', 'is_admin', 'is_active']);
  const vlans = await readTsv('vlans.tsv', ['vlan_id', 'description']);
  const requests = await readTsv('requests.tsv', [
    'user_subject',
    'vlan_id',
    'status',
    'updated_by_subject',
    'created_by_subject'
  ]);

  validateUserData(users);
  validateVlanData(vlans);
  validateRequestData(requests, users, vlans);

  const sqlParts = [
    '-- Auto-generated by docker/postgres/dev/generate-sample-data.js',
    '-- Source TSV files located in docker/postgres/dev/tsv',
    '',
    renderUserInserts(users),
    '',
    renderVlanInserts(vlans),
    '',
    renderRequestInserts(requests)
  ];

  const sql = sqlParts.join('\n').trimEnd() + '\n';
  await fs.writeFile(OUTPUT_FILE, sql);
}

async function readTsv(fileName, expectedHeaders) {
  const filePath = path.join(TSV_DIR, fileName);
  let content;
  try {
    content = await fs.readFile(filePath, 'utf8');
  } catch (error) {
    throw new Error(`Failed to read ${filePath}: ${error.message}`);
  }

  const lines = content
    .split(/\r?\n/)
    .map(line => line.trim())
    .filter(line => line.length > 0 && !line.startsWith('#'));

  if (lines.length === 0) {
    throw new Error(`No data found in ${filePath}`);
  }

  const headers = lines.shift().split('\t');
  ensureHeaders(expectedHeaders, headers, filePath);

  return lines.map((line, index) => {
    const columns = line.split('\t');
    if (columns.length !== headers.length) {
      throw new Error(
        `Invalid column count in ${filePath} (data row ${index + 2}); expected ${headers.length} but received ${columns.length}`
      );
    }
    return headers.reduce((acc, header, i) => {
      acc[header] = columns[i];
      return acc;
    }, {});
  });
}

function ensureHeaders(expected, actual, filePath) {
  if (expected.length !== actual.length) {
    throw new Error(
      `Unexpected header count in ${filePath}; expected ${expected.length} columns but received ${actual.length}`
    );
  }

  expected.forEach((header, index) => {
    if (header !== actual[index]) {
      throw new Error(
        `Unexpected header "${actual[index]}" at position ${index + 1} in ${filePath}; expected "${header}"`
      );
    }
  });
}

function validateUserData(users) {
  const seenSubjects = new Set();

  users.forEach((user, index) => {
    if (!user.subject) {
      throw new Error(`users.tsv row ${index + 2} is missing a subject`);
    }
    if (seenSubjects.has(user.subject)) {
      throw new Error(`Duplicate subject "${user.subject}" detected in users.tsv`);
    }
    seenSubjects.add(user.subject);
    parseBoolean(user.is_admin, `users.tsv row ${index + 2} (is_admin)`);
    parseBoolean(user.is_active, `users.tsv row ${index + 2} (is_active)`);
  });
}

function validateVlanData(vlans) {
  const seenVlanIds = new Set();

  vlans.forEach((vlan, index) => {
    const vlanId = parseInt(vlan.vlan_id, 10);
    if (Number.isNaN(vlanId)) {
      throw new Error(`vlans.tsv row ${index + 2} contains invalid vlan_id "${vlan.vlan_id}"`);
    }
    if (seenVlanIds.has(vlanId)) {
      throw new Error(`Duplicate vlan_id "${vlanId}" detected in vlans.tsv`);
    }
    seenVlanIds.add(vlanId);
  });
}

function validateRequestData(requests, users, vlans) {
  const userSubjects = new Set(users.map(user => user.subject));
  const vlanIds = new Set(vlans.map(vlan => parseInt(vlan.vlan_id, 10)));

  requests.forEach((request, index) => {
    const row = `requests.tsv row ${index + 2}`;
    ensureUserExists(request.user_subject, userSubjects, `${row} (user_subject)`);
    ensureUserExists(request.updated_by_subject, userSubjects, `${row} (updated_by_subject)`);
    ensureUserExists(request.created_by_subject, userSubjects, `${row} (created_by_subject)`);

    const vlanId = parseInt(request.vlan_id, 10);
    if (Number.isNaN(vlanId)) {
      throw new Error(`${row} contains invalid vlan_id "${request.vlan_id}"`);
    }
    if (!vlanIds.has(vlanId)) {
      throw new Error(`${row} references unknown vlan_id "${vlanId}"`);
    }

    const status = request.status.toLowerCase();
    if (!REQUEST_STATUS.has(status)) {
      throw new Error(`${row} has unsupported status "${request.status}"`);
    }
  });
}

function ensureUserExists(subject, subjects, context) {
  if (!subject) {
    throw new Error(`Missing subject in ${context}`);
  }
  if (!subjects.has(subject)) {
    throw new Error(`Unknown subject "${subject}" referenced in ${context}`);
  }
}

function renderUserInserts(users) {
  const values = users
    .map(user => {
      const columns = [
        quoteString(user.subject),
        quoteString(user.name),
        parseBoolean(user.is_admin, `users.tsv (${user.subject})`),
        parseBoolean(user.is_active, `users.tsv (${user.subject})`)
      ];
      return `  (${columns.join(', ')})`;
    })
    .join(',\n');

  return [
    'INSERT INTO users (subject, name, is_admin, is_active)',
    'VALUES',
    values,
    'ON CONFLICT (subject) DO NOTHING;'
  ].join('\n');
}

function renderVlanInserts(vlans) {
  const values = vlans
    .map(vlan => {
      const vlanId = parseInt(vlan.vlan_id, 10);
      return `  (${vlanId}, ${quoteString(vlan.description)})`;
    })
    .join(',\n');

  return [
    'INSERT INTO vlans (vlan_id, description)',
    'VALUES',
    values,
    'ON CONFLICT (vlan_id) DO NOTHING;'
  ].join('\n');
}

function renderRequestInserts(requests) {
  return requests
    .map(request => {
      const userSubject = quoteString(request.user_subject);
      const updatedSubject = quoteString(request.updated_by_subject);
      const createdSubject = quoteString(request.created_by_subject);
      const vlanId = parseInt(request.vlan_id, 10);
      const status = quoteString(request.status.toLowerCase());

      return [
        'WITH request_data AS (',
        `  SELECT`,
        `    (SELECT id FROM users WHERE subject = ${userSubject}) AS user_id,`,
        `    ${vlanId} AS vlan_id,`,
        `    ${status}::text AS status,`,
        `    (SELECT id FROM users WHERE subject = ${updatedSubject}) AS updated_by,`,
        `    (SELECT id FROM users WHERE subject = ${createdSubject}) AS created_by`,
        ')',
        'INSERT INTO requests (user_id, vlan_id, status, updated_by, created_by)',
        'SELECT user_id, vlan_id, status, updated_by, created_by',
        'FROM request_data',
        'WHERE user_id IS NOT NULL',
        '  AND vlan_id IS NOT NULL',
        '  AND updated_by IS NOT NULL',
        '  AND created_by IS NOT NULL',
        '  AND NOT EXISTS (',
        '    SELECT 1',
        '    FROM requests r',
        '    WHERE r.user_id = request_data.user_id',
        '      AND r.vlan_id = request_data.vlan_id',
        '  );'
      ].join('\n');
    })
    .join('\n\n');
}

function quoteString(value) {
  return `'${value.replace(/'/g, "''")}'`;
}

function parseBoolean(value, context) {
  const normalized = value.trim().toLowerCase();
  if (normalized === 'true') {
    return 'TRUE';
  }
  if (normalized === 'false') {
    return 'FALSE';
  }
  throw new Error(`Invalid boolean "${value}" in ${context}; expected TRUE or FALSE`);
}

main().catch(error => {
  console.error(error instanceof Error ? error.message : error);
  process.exitCode = 1;
});
